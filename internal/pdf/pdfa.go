package pdf

import (
	"bytes"
	"compress/zlib"
	"fmt"
	"time"
)

// ConvertPDFDateToXMP converts a PDF date string (D:YYYYMMDDHHmmSSOHH'mm') to XMP format (YYYY-MM-DDTHH:mm:ss+HH:MM)
func ConvertPDFDateToXMP(pdfDate string) string {
	// PDF format: D:20060102150405-07'00' or D:20060102150405+05'30'
	// XMP format: 2006-01-02T15:04:05-07:00 or 2006-01-02T15:04:05+05:30
	if len(pdfDate) < 16 {
		return time.Now().Format("2006-01-02T15:04:05-07:00")
	}

	// Remove 'D:' prefix
	date := pdfDate[2:]

	year := date[0:4]
	month := date[4:6]
	day := date[6:8]
	hour := date[8:10]
	min := date[10:12]
	sec := date[12:14]

	// Parse timezone: -07'00' or +05'30'
	// Format is: sign + 2 digits + quote + 2 digits + quote
	tz := "+00:00"
	if len(date) >= 20 {
		tzSign := string(date[14])
		tzHour := date[15:17]
		// Skip the quote at position 17, get minutes at 18-19
		tzMin := date[18:20]
		tz = tzSign + tzHour + ":" + tzMin
	}

	return fmt.Sprintf("%s-%s-%sT%s:%s:%s%s", year, month, day, hour, min, sec, tz)
}

// GenerateXMPMetadata generates PDF/A-1b compliant XMP metadata
// pdfDateStr should be in PDF format: D:YYYYMMDDHHmmSSOHH'mm'
func GenerateXMPMetadata(documentID string, pdfDateStr string) string {
	// Convert PDF date to XMP date format for consistency
	xmpDateStr := ConvertPDFDateToXMP(pdfDateStr)

	xmp := `<?xpacket begin="` + "\xef\xbb\xbf" + `" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/">
  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
    <rdf:Description rdf:about=""
        xmlns:dc="http://purl.org/dc/elements/1.1/"
        xmlns:xmp="http://ns.adobe.com/xap/1.0/"
        xmlns:pdf="http://ns.adobe.com/pdf/1.3/"
        xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/">
      <dc:format>application/pdf</dc:format>
      <dc:creator>
        <rdf:Seq>
          <rdf:li>GoPDFSuit</rdf:li>
        </rdf:Seq>
      </dc:creator>
      <dc:title>
        <rdf:Alt>
          <rdf:li xml:lang="x-default">PDF Document</rdf:li>
        </rdf:Alt>
      </dc:title>
      <xmp:CreatorTool>GoPDFSuit PDF Generator</xmp:CreatorTool>
      <xmp:CreateDate>` + xmpDateStr + `</xmp:CreateDate>
      <xmp:ModifyDate>` + xmpDateStr + `</xmp:ModifyDate>
      <pdf:Producer>GoPDFSuit</pdf:Producer>
      <pdfaid:part>1</pdfaid:part>
      <pdfaid:conformance>B</pdfaid:conformance>
    </rdf:Description>
  </rdf:RDF>
</x:xmpmeta>
<?xpacket end="w"?>`

	return xmp
}

// GenerateXMPMetadataObject generates the XMP metadata stream object
// pdfDateStr should be in PDF format: D:YYYYMMDDHHmmSSOHH'mm'
func GenerateXMPMetadataObject(objectID int, documentID string, pdfDateStr string) string {
	xmpData := GenerateXMPMetadata(documentID, pdfDateStr)

	return fmt.Sprintf("%d 0 obj\n<< /Type /Metadata /Subtype /XML /Length %d >>\nstream\n%s\nendstream\nendobj\n",
		objectID, len(xmpData), xmpData)
}

// sRGBICCProfile is a minimal sRGB ICC profile for PDF/A compliance
// This is a simplified sRGB profile that meets PDF/A requirements
var sRGBICCProfile = []byte{
	0x00, 0x00, 0x02, 0x0c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,
	0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,
	0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,
	0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,
	0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x48, 0x50, 0x20, 0x20,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
	0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x33,
	0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x6c,
	0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x01, 0x90, 0x00, 0x00, 0x00, 0x14,
	0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x01, 0xa4, 0x00, 0x00, 0x00, 0x14,
	0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x01, 0xb8, 0x00, 0x00, 0x00, 0x14,
	0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x01, 0xcc, 0x00, 0x00, 0x00, 0x14,
	0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x10,
	0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x10,
	0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x10,
	0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x6f, 0x70, 0x79,
	0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x31, 0x39,
	0x39, 0x38, 0x20, 0x48, 0x65, 0x77, 0x6c, 0x65, 0x74, 0x74, 0x2d, 0x50,
	0x61, 0x63, 0x6b, 0x61, 0x72, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61,
	0x6e, 0x79, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x12, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43,
	0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x73, 0x52, 0x47,
	0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32,
	0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x16, 0xcc,
	0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa2,
	0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x99, 0x00, 0x00, 0xb7, 0x85,
	0x00, 0x00, 0x18, 0xda, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x24, 0xa0, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xcf,
	0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x33, 0x00, 0x00,
}

// GenerateICCProfileObject generates the ICC profile stream object for sRGB
// Returns the bytes to write to the PDF buffer
func GenerateICCProfileObject(objectID int) []byte {
	// Compress the ICC profile
	var compressedBuf bytes.Buffer
	zlibWriter := zlib.NewWriter(&compressedBuf)
	zlibWriter.Write(sRGBICCProfile)
	zlibWriter.Close()
	compressedData := compressedBuf.Bytes()

	// Build the object with proper binary stream handling
	var result bytes.Buffer
	result.WriteString(fmt.Sprintf("%d 0 obj\n<< /Filter /FlateDecode /Length %d /N 3 /Alternate /DeviceRGB >>\nstream\n",
		objectID, len(compressedData)))
	result.Write(compressedData)
	result.WriteString("\nendstream\nendobj\n")

	return result.Bytes()
}

// GenerateOutputIntentObject generates the OutputIntent object for PDF/A-1
func GenerateOutputIntentObject(objectID int, iccProfileID int) string {
	return fmt.Sprintf("%d 0 obj\n<< /Type /OutputIntent /S /GTS_PDFA1 /OutputConditionIdentifier (sRGB IEC61966-2.1) /RegistryName (http://www.color.org) /Info (sRGB IEC61966-2.1) /DestOutputProfile %d 0 R >>\nendobj\n",
		objectID, iccProfileID)
}
