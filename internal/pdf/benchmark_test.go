package pdf

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/chinmay-sawant/gopdfsuit/v4/internal/models"
)

type BenchmarkRecord struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
	Role  string `json:"role"`
	Desc  string `json:"desc"`
}

func loadBenchmarkData() []BenchmarkRecord {
	file, err := os.Open("../../sampledata/benchmarks/data.json")
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			panic(err)
		}
	}()

	var records []BenchmarkRecord
	if err := json.NewDecoder(file).Decode(&records); err != nil {
		panic(err)
	}
	return records
}

func getGoPdfSuitTemplate(records []BenchmarkRecord) models.PDFTemplate {
	template := models.PDFTemplate{
		Config: models.Config{
			Page:          "A4",
			PageAlignment: 1,
			PageBorder:    "10:10:10:10",
			PdfTitle:      "User Report",
		},
		Title: models.Title{
			Text:  "User Report",
			Props: "Helvetica:24:100:center:0:0:0:0",
		},
		Footer: models.Footer{
			Font: "Helvetica:10:000:center",
			Text: "Generated by gopdfsuit",
		},
	}

	rows := make([]models.Row, len(records))
	for i, r := range records {
		rows[i] = models.Row{
			Row: []models.Cell{
				{Props: "Helvetica:10:000:left:1:1:1:1", Text: fmt.Sprint(r.ID)},
				{Props: "Helvetica:10:000:left:1:1:1:1", Text: r.Name},
				{Props: "Helvetica:10:000:left:1:1:1:1", Text: r.Email},
				{Props: "Helvetica:10:000:left:1:1:1:1", Text: r.Role},
				{Props: "Helvetica:10:000:left:1:1:1:1", Text: r.Desc},
			},
		}
	}

	template.Table = []models.Table{{
		MaxColumns:   5,
		ColumnWidths: []float64{0.5, 1.5, 2, 1.5, 3},
		Rows:         rows,
	}}
	return template
}

func BenchmarkGoPdfSuit(b *testing.B) {
	records := loadBenchmarkData()
	template := getGoPdfSuitTemplate(records)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		pdfBytes, err := GenerateTemplatePDF(template)
		if err != nil {
			b.Fatalf("Failed to generate PDF: %v", err)
		}
		if len(pdfBytes) == 0 {
			b.Fatalf("Generated empty PDF")
		}
		if i == 0 {
			_ = os.WriteFile("../../sampledata/benchmarks/gopdfsuit/output.pdf", pdfBytes, 0644)
		}
	}
}

func BenchmarkTypst(b *testing.B) {
	absPath, _ := filepath.Abs("../../sampledata/benchmarks/typst-x86_64-unknown-linux-musl/typst")
	typFilePath, _ := filepath.Abs("../../sampledata/benchmarks/typst/benchmark.typ")

	// Output to typst folder
	outPath, _ := filepath.Abs("../../sampledata/benchmarks/typst/output.pdf")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Output to file
		cmd := exec.Command(absPath, "compile", typFilePath, outPath)
		// Set Cwd so Typst can find data.json
		cmd.Dir = filepath.Dir(typFilePath)

		if output, err := cmd.CombinedOutput(); err != nil {
			b.Fatalf("Typst failed: %v, Output: %s", err, string(output))
		}
	}
}
